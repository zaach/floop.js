DEFINE PROCEDURE ''PIERRE?'' [A,B,C]:
BLOCK 0: BEGIN
	IF TRIVIAL? [A,B,C,2], THEN:
	OUTPUT ⇐ YES;
BLOCK 0: END.

DEFINE PROCEDURE ''LOG-BASE'' [B,N]:
BLOCK 0: BEGIN
	CELL(0) ⇐ 1;
	LOOP AT MOST N TIMES:
	BLOCK 1: BEGIN
		CELL(0) ⇐ CELL(0) × B;
		IF CELL(0) > N, THEN:
		ABORT LOOP 1;
		OUTPUT ⇐ OUTPUT + 1;
	BLOCK 1: END;
BLOCK 0: END.

DEFINE PROCEDURE ''POWER-MOD'' [A,B,M]:
BLOCK 0: BEGIN
	OUTPUT ⇐ 1;
	LOOP B TIMES:
	BLOCK 1: BEGIN
		OUTPUT ⇐ OUTPUT × A;
		OUTPUT ⇐ REMAINDER [OUTPUT, M];
	BLOCK 1: END;
BLOCK 0: END.

DEFINE PROCEDURE ''INVERSE-MOD'' [X,M]:
BLOCK 0: BEGIN
	CELL(0) ⇐ X;
	CELL(1) ⇐ M;
	CELL(2) ⇐ 1;
	CELL(3) ⇐ 0;
	LOOP AT MOST M TIMES:
	BLOCK 1: BEGIN
		IF CELL(1) = 0, THEN:
		ABORT LOOP 1;

		CELL(4) ⇐ DIVIDE [CELL(0),CELL(1)];

		CELL(5) ⇐ CELL(1) × CELL(4);
		CELL(5) ⇐ MINUS [CELL(0),CELL(5)];
		CELL(0) ⇐ CELL(1);
		CELL(1) ⇐ CELL(5);

		CELL(5) ⇐ CELL(3) × CELL(4);
		LOOP AT MOST CELL(5) TIMES:
		BLOCK 2: BEGIN
			IF CELL(2) = CELL(5), THEN:
			ABORT LOOP 2;
			IF CELL(2) > CELL(5), THEN:
			ABORT LOOP 2;
			CELL(2) ⇐ CELL(2) + M;
		BLOCK 2: END;
		CELL(5) ⇐ MINUS [CELL(2),CELL(5)];
		CELL(2) ⇐ CELL(3);
		CELL(3) ⇐ CELL(5);
	BLOCK 1: END;
	OUTPUT ⇐ CELL(2);
BLOCK 0: END.

DEFINE PROCEDURE ''MULTIPLICITY'' [P,N]:
BLOCK 0: BEGIN
	CELL(0) ⇐ N;
	LOOP AT MOST N TIMES:
	BLOCK 1: BEGIN
		IF REMAINDER [CELL(0),P] > 0, THEN:
		ABORT LOOP 1;
		CELL(0) ⇐ DIVIDE [CELL(0), P];
		OUTPUT ⇐ OUTPUT + 1;
	BLOCK 1: END;
BLOCK 0: END.

DEFINE PROCEDURE ''NOT-PRIME?'' [N]:
BLOCK 0: BEGIN
	OUTPUT ⇐ YES;
	IF PRIME? [N], THEN:
	OUTPUT ⇐ NO;
BLOCK 0: END.

DEFINE PROCEDURE ''PI-DIGIT'' [N]:
BLOCK 0: BEGIN
	CELL(0) ⇐ N + 10;
	CELL(0) ⇐ CELL(0) × 4;
	CELL(1) ⇐ CELL(0) × 2;

	OUTPUT ⇐ 0;

	CELL(2) ⇐ 2;
	LOOP CELL(1) TIMES:
	BLOCK 1: BEGIN
		CELL(2) ⇐ CELL(2) + 1;
		IF NOT-PRIME? [CELL(2)], THEN:
		QUIT BLOCK 1;

		CELL(3) ⇐ LOG-BASE [CELL(2),CELL(1)];
		CELL(4) ⇐ POWER [CELL(2),CELL(3)];

		CELL(5) ⇐ 1;
		CELL(6) ⇐ 1;
		CELL(7) ⇐ 0;
		CELL(8) ⇐ 0;
		CELL(9) ⇐ 0;

		CELL(10) ⇐ 1;
		LOOP CELL(0) TIMES:
		BLOCK 2: BEGIN
			CELL(11) ⇐ MULTIPLICITY [CELL(2),CELL(10)];
			CELL(100) ⇐ 2 × CELL(10);
			CELL(100) ⇐ MINUS [CELL(100),1];
			CELL(12) ⇐ MULTIPLICITY [CELL(2),CELL(100)];

			CELL(101) ⇐ CELL(5) × CELL(10);
			CELL(5) ⇐ REMAINDER [DIVIDE [CELL(101),POWER [CELL(2),CELL(11)]],CELL(4)];
			CELL(102) ⇐ CELL(6) × CELL(100);
			CELL(6) ⇐ REMAINDER [DIVIDE [CELL(102),POWER [CELL(2),CELL(12)]],CELL(4)];

			CELL(8) ⇐ CELL(8) + CELL(11);
			CELL(9) ⇐ CELL(9) + CELL(12);

			IF CELL(9) > CELL(8), THEN:
			BLOCK 3: BEGIN
				CELL(103) ⇐ CELL(10) × CELL(5);
				CELL(103) ⇐ CELL(103) × INVERSE-MOD [CELL(6),CELL(4)];
				CELL(103) ⇐ CELL(103) × POWER-MOD [CELL(2),MINUS [CELL(3),MINUS [CELL(9),CELL(8)]],CELL(4)];
				CELL(103) ⇐ CELL(103) + CELL(7);
				CELL(7) ⇐ REMAINDER [CELL(103),CELL(4)];
			BLOCK 3: END;

			CELL(10) ⇐ CELL(10) + 1;
		BLOCK 2: END;

		CELL(104) ⇐ POWER-MOD [10,MINUS [N,1],CELL(4)];
		CELL(104) ⇐ CELL(104) × CELL(7);
		CELL(7) ⇐ REMAINDER [CELL(104),CELL(4)];

		CELL(105) ⇐ 10000 × CELL(7);
		CELL(105) ⇐ DIVIDE [CELL(105),CELL(4)];

		OUTPUT ⇐ OUTPUT + CELL(105);
		OUTPUT ⇐ REMAINDER [OUTPUT,10000];
	BLOCK 1: END;
	OUTPUT ⇐ DIVIDE [OUTPUT, 1000];
BLOCK 0: END.
